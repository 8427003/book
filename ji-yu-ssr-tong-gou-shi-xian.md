一、框架期望实现的效果

1、前端项目是spa项目，且具有资源按页分包加载特性。

2、服务端不参与webpack编译。即只编译前端工程，编译好的产物作为一个中间件引入服务端项目。

3、spa项目最好只编译一次，不因为是否作为ssr项目模式而区别编译。

4、ssr项目模式和普通spa模式项目能无缝互转。实现开发还是走普通的spa的模式，只是生产可以快速构建为ssr模式项目。前端项目能够独立运行，包括开发和生产阶段在没有后端项目时能够独立运行。且加上后端项目后能够简单转变为ssr项目模式。

二、关键实现与思路

1、选择spa项目。spa项目跟多页项目具有较大不同。spa项目必定包含路由模块，最终向外暴露一个app。多页项目，最终向外暴露每个页面模块。在作为服务端项目依赖时，spa项目作为更单一模块被引入，而多页项目必须再次架构与封装访问url与页面的对应关系，这个过程恰好是重写一个路由。如果多页项目不考虑这步封装，那么只有硬编码url 与页面模块绑定，会增加开发阶段工作量。

2、将spa路由按页分包异步转为同步化。由于spa项目多采用按页分包加载。这种情况下，路由path不直接和页面组件绑定，而是和一个“高阶组件”绑定。这个“高阶组件“其实是一个占位作用。当用户访问url，路由先渲染高级组件，由这个高阶组件去异步获取该url对应模块的分包。当分包下载完毕且模块加载ready后，高级组件重新渲染真正的模块。这个高阶占位组件我们使用的是开源库react-loadable，实现并不复杂。react-loadable 也有ssr方案，其实这套方案就是解决异步转为同步问题，但是这个套方案使用并不不友好。所以我们重写了。以上我们介绍了react-loadable的原理，下面我们来具体分析如何实现异步转同步。

往简单说，当输入一个url给咱们的路由模块时，路由应该返回给我们url对应的模块组件 。然后咱们拿这个模块组件去调用服务端渲染api，就可以得到字符串dom。但是你会发现基于代码按页分包路由，你只会得到“占位组件“。除非你实现一个占位组件，把两部分切割开。第一部分，你先让占位组件加载分包组件，然后回调你，说分包组建已经ready。第二部，当你再次调用这个占位组件，让它自动检测，是否你需要的模块已经ready，如果ready直接返回真正的url对应的模块组件。占位组件由于第一步去访问网络了，第二部就不用访问网络，所以就是同步了。

3、输入访问url，经过路由，最后要得到分包的静态资源路径。因为服务端渲染api 实际上只是为你拼接一个字符串。当这个字符串到前端后，需要显示样式，相应事件等。所以这个页面组件对应css 和 js 资源必须手动挂在到相应的位置。我们利用了webpack 特殊参数会产生一个stats.json，里面会描述了import\(‘模块path’\)（我们使用import\(\)来实现分包的），模块对应的bundle，即css和js。这里有些细节，url 最终能算出对应的css 和js，需要加强下import（‘模块path'\)，在build阶段暴露更多数据。我们写了babel-import 增强插件\(这里不清晰，是不必须\)

4、

