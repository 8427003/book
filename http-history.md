http大致经历了0.9、1.0、和现在我们用的1.1三个重要的版本。

### 每请求一次，重新建立连接（“短连接”）

[http0.9](https://www.w3.org/Protocols/HTTP/AsImplemented.html) 大概是1991年发布的，只支持get请求，基本只支持下载html文档，其实这是可以理解的。早在10多年前，我们用的是拨号上网，那网速真可称得上龟速。那时我们的网页是啥样的呢，大概跟以前塞班上的wap页面差不多，估计还要差一点。wap页面可以有图片了，而http0.9的那个年代能把文档下载下来就差不多了。我们重点关注http0.9时的连接。短连接模型如图所示：





### HTTP persistent connection（“长连接”）

到了[http1.0](https://www.w3.org/Protocols/HTTP/1.0/spec.html)，这个时候加入了post等方式.这个时候网页基本可以与后端进行交互了。在http1.0前期，我们依然采用的是“短连接”，但与此同时我们的网络建设发展迅速，网页逐渐变得庞大起来，已经不再是只有文档了，还包括其它资源：图片，脚本，样式等等。并且在一个页面里面，这些资源越来越多。要知道tcp建立连接从性能和时间上是有损耗的，tcp建立连接时光三次握手就是一个很大的时间损耗，还包我们建立了连接要销毁连接等等。所以在http1.0后期有人提出了persistent connection，并在[http1.1](https://www.w3.org/Protocols/rfc2616/rfc2616.html)的时候写入标准。长链接模型如图所示：

### 

### http pipelining

虽然http1.1已经有了“长链接“，但是后来人们发现还有可优化的地方。长链接减少了连接创建销毁带来的损耗，但是每次发起新的请求必须等到上一次请求完毕后才能开始。举个例子用一个连接请求两张图片，如果a.jpg, b.jgp 他们是这样的

pipelining技术可以让它们并行发送请求，但是有一点要求，响应必须按发送请求的顺序发回。



这导致了一个问题[Head-of-line blocking](https://en.wikipedia.org/wiki/Head-of-line_blocking)\(队头阻塞）。这个问题百科上讲得有些复杂，其实pipelining技术要求响应必须按请求顺序返回，要是你第一个请求的响应时间太长（比如是一个大图片），或者丢包等等，那第二个请求的响应就不好处理了，它必须得让第一个请求相应完毕后才能响应。因此后面的响应会被前面的响应卡住。理论上看，http pipelining 应该让http得到部分优化（它至少让请求并行发出去了），但是从实践中数据分析，这项技术并没有让http得到太多提升可参考文章，加上在定这项技术标准的时候留给实现者的自由发挥空间太大，导致实现上也是各有不同，而且很复杂。所以现在浏览器基本都是默认关闭这项技术。 









